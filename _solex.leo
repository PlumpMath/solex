<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<?xml-stylesheet ekr_test?>
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="cslos77.20141120103746.40" a="E"><vh>solex</vh>
<v t="cslos77.20141120192122.72" a="E"><vh>scripts</vh>
<v t="cslos77.20141120103746.41"><vh>@shadow solex.py</vh></v>
<v t="cslos77.20150302085211.106"><vh>@shadow server.py</vh></v>
<v t="cslos77.20141120192122.9"><vh>@shadow planet_gen.py</vh></v>
<v t="cslos77.20141120192122.71"><vh>@shadow _build_spheres.py</vh></v>
<v t="cslos77.20141120192122.82"><vh>@shadow _build_planet.py</vh></v>
</v>
<v t="cslos77.20141120192122.4" a="E"><vh>@path etc</vh>
<v t="cslos77.20141120192122.6"><vh>@shadow settings.py</vh></v>
<v t="cslos77.20141120192122.7"><vh>@shadow util.py</vh></v>
<v t="cslos77.20141212010436.3"
expanded="cslos77.20141212010436.4,"><vh>@shadow shiva.py</vh></v>
</v>
<v t="cslos77.20150302085211.3" a="E"><vh>@path net</vh>
<v t="cslos77.20150302085211.6"><vh>@shadow net.py</vh></v>
<v t="cslos77.20150302085211.4" a="E"
expanded="cslos77.20150302085211.7,"><vh>@shadow client.py</vh></v>
<v t="cslos77.20150302085211.5"><vh>@shadow server.py</vh></v>
</v>
<v t="cslos77.20141120192122.10" a="E"><vh>@path solex</vh>
<v t="cslos77.20150302085211.122" a="E"
expanded="cslos77.20150302085211.70,cslos77.20150302085211.124,"><vh>@shadow views.py</vh></v>
<v t="cslos77.20150302085211.123" a="E"><vh>@shadow bodies.py</vh></v>
<v t="cslos77.20141120192122.11"><vh>@shadow environment.py</vh></v>
<v t="cslos77.20141120192122.13" a="E"><vh>@shadow cameras.py</vh></v>
<v t="cslos77.20141122021629.8"><vh>@shadow shader.py</vh></v>
<v t="cslos77.20141213043440.2"><vh>@shadow texture.py</vh></v>
<v t="cslos77.20150302085211.104"
expanded="cslos77.20150302085211.105,"><vh>@shadow simulator.py</vh></v>
</v>
<v t="cslos77.20141120192122.8"><vh>@path planet_gen</vh>
<v t="cslos77.20141120192122.28"
expanded="cslos77.20141120192122.29,"><vh>@shadow planet_gen.py</vh></v>
<v t="cslos77.20141120192122.52"><vh>@shadow model.py</vh></v>
</v>
<v t="cslos77.20141129025015.19"><vh>@path gpu</vh>
<v t="cslos77.20141129025015.26"><vh>scripts</vh>
<v t="cslos77.20141129025015.27"><vh>@shadow _swizzle_demo.py</vh></v>
<v t="cslos77.20141129025015.29"><vh>@shadow _gen_normal_map.py</vh></v>
<v t="cslos77.20141125093326.10"><vh>__generate_Normal_Map (cpu)</vh></v>
</v>
<v t="cslos77.20141129025015.21"><vh>@shadow panda3d_gpu.py</vh></v>
<v t="cslos77.20141125093326.15"><vh>@shadow gpu_image_lib.glsl</vh></v>
<v t="cslos77.20141122021629.9" a="E"><vh>@path shaders</vh>
<v t="cslos77.20141122021629.10"><vh>@shadow planet_VERT.glsl</vh></v>
<v t="cslos77.20141125093326.4"><vh>@shadow planet_TESC.glsl</vh></v>
<v t="cslos77.20141125093326.5"><vh>@shadow planet_TESE.glsl</vh></v>
<v t="cslos77.20141222013217.2"><vh>@shadow planet_FRAG.glsl</vh></v>
</v>
</v>
<v t="cslos77.20141120192122.20" a="E"><vh>@path gui</vh>
<v t="cslos77.20141120192122.22"><vh>@shadow ueh.py</vh></v>
<v t="cslos77.20150302085211.8" a="E"
expanded="cslos77.20150302085211.137,"><vh>@shadow gui.py</vh></v>
<v t="cslos77.20150302085211.9" a="E"><vh>@path p3gui</vh>
<v t="cslos77.20150302085211.12" a="E"
expanded="cslos77.20150302085211.33,cslos77.20150302085211.35,cslos77.20150302085211.46,cslos77.20150302085211.47,cslos77.20150302085211.62,"><vh>@shadow p3gui.py</vh></v>
</v>
</v>
<v t="cslos77.20141120192122.37" a="E"><vh>@path data</vh>
<v t="cslos77.20141120192122.38" a="E"><vh>@path systems</vh>
<v t="cslos77.20141213081755.5"><vh>@shadow _default.shv</vh></v>
<v t="cslos77.20150302085211.108"><vh>@shadow sol.shv</vh></v>
</v>
<v t="cslos77.20141214080158.2" a="E"><vh>@path bodies</vh>
<v t="cslos77.20141210210514.5"><vh>@shadow earth/earth.shv</vh></v>
<v t="cslos77.20150302085211.117"><vh>@shadow mars/mars.shv</vh></v>
<v t="cslos77.20150302085211.118"><vh>@shadow moon/moon.shv</vh></v>
</v>
</v>
<v t="cslos77.20141122021629.14"><vh>@path test</vh>
<v t="cslos77.20141122021629.15"><vh>@shadow main.py</vh></v>
<v t="cslos77.20141122021629.16"><vh>@shadow ShaderCombiner.py</vh></v>
<v t="cslos77.20141122021629.17"><vh>@shadow shader.glsl</vh></v>
<v t="cslos77.20141129025015.9"><vh>@shadow compute_test.py</vh></v>
<v t="cslos77.20141219120401.5"><vh>@shadow planet_GEOM.glsl</vh></v>
<v t="cslos77.20141214080158.5"><vh>shiva demo</vh></v>
<v t="cslos77.20141214080158.6"><vh>shiva ref</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="cslos77.20141120103746.40">@language python
@tabwidth -4

# =====
# To Do
# =====

# - sea geometry
# - find ideal sizes for height and color maps

# panda bugs:
# - Material.specular bug
# - comp shader: imageStore error


</t>
<t tx="cslos77.20141120192122.10"></t>
<t tx="cslos77.20141120192122.20"></t>
<t tx="cslos77.20141120192122.37"></t>
<t tx="cslos77.20141120192122.38"></t>
<t tx="cslos77.20141120192122.4"></t>
<t tx="cslos77.20141120192122.72"></t>
<t tx="cslos77.20141120192122.8"></t>
<t tx="cslos77.20141122021629.14"></t>
<t tx="cslos77.20141122021629.9"></t>
<t tx="cslos77.20141125093326.10">def __generate_Normal_Map(self, recipe):
    map_path = "{}/data/bodies/{}/maps".format(_path.SOLEX, recipe['name'].lower())
    height_map_path = "{}/{}".format(map_path, recipe['height_map'])
    hm = PNMImage()
    hm.read(Filename(height_map_path))
    x_size, y_size = hm.getXSize(), hm.getYSize()
    norm_map = PNMImage(x_size, y_size)
    _top = -recipe['min_elevation']+recipe['max_elevation']
    
    c_pt, tot_norm = LVector3f(0,0,0), LVector3f(0,0,0)
    pts = list(map(lambda a: LVector3f(0,0,0), range(8)))
    
    # Height_matrix tracks bright vals surrounding (x,y).
    c = [[-1, -1, -1],
         [-1, hm.getBright(x_size-1,0)*_top, hm.getBright(0,0)*_top],
         [-1, hm.getBright(x_size-1,0)*_top, hm.getBright(0,0)*_top]]
    
    with TimeIt("Generate norms"):
        _y, _x = y_size-1, x_size-1
        for y in range(y_size):
            # Update mat rows by removing the first and append the next.
            yy = y+1 if y &lt; y_size-1 else 0
            _coords = ((_x,yy),(0,yy),(1,yy))
            # Construct next (bottom) row.
            c.pop(0)
            new_row = []
            for i in range(3):
                new_row.append(hm.getBright(*_coords[i])*_top)
            c.append(new_row)
            
            for x in range(x_size):
                # Update mat columns by removing the 1st and appending the next.
                xx = x+1 if x &lt; x_size-1 else 0
                _coords = ((xx,_y),(xx,y),(xx,yy))
                # Construct next (right hand) column)
                for i in range(3):
                    c[i].pop(0)
                    c[i].append(hm.getBright(*_coords[i])*_top)
                    
                # Find normal for (x,y) by calculating planes based
                # on hypothetical pts surrounding (x,y) in matrix.
                c_pt.set(x,y,c[1][1])
                pts[0].set(_x,_y,c[0][0])
                pts[1].set(x,_y,c[0][1])
                pts[2].set(xx,_y,c[0][2])
                pts[3].set(xx,y,c[1][2])
                pts[4].set(xx,yy,c[2][2])
                pts[5].set(x,yy,c[2][1])
                pts[6].set(_x,yy,c[2][0])
                pts[7].set(_x,y,c[1][0])
                
                _prev_vec = c_pt-pts[7]
                tot_norm.set(0,0,1)
                for p in reversed(pts):
                    vec = c_pt-p
                    tri_norm = vec.cross(_prev_vec)
                    tri_norm.normalize()
                    tot_norm += tri_norm
                    _prev_vec = vec
                norm = tot_norm/8
                norm.normalize()
                
                # Write norm to norm_map (nm) as colour.
                r = (norm[0]+1) / 2
                g = (norm[1]+1) / 2
                b = (norm[2]+1) / 2
    
                norm_map.setRed(x, y, r)
                norm_map.setGreen(x, y, g)
                norm_map.setBlue(x, y, b)
                
                _x = x
            _y = y
    
        # Write norm map to disc as jpeg.
        norm_map_path = "{}/{}_norm.jpeg".format(map_path, recipe['name'].lower())
        norm_map.write(Filename(norm_map_path))
    
        
</t>
<t tx="cslos77.20141129025015.19"></t>
<t tx="cslos77.20141129025015.26"></t>
<t tx="cslos77.20141214080158.2"></t>
<t tx="cslos77.20141214080158.5">@language shiva

// Object def.
composite active Thruster:
    $radius = 1.2
    
    component XXA_Fuel_Rod_v23 as $fuel_rod
    
// Demo animate statement ("animate" qualifier.)
animate:
    if $TARGET:
        if velocity($TARGET) &gt; 100:
            push("adj_thrust", direction($TARGET) * extract($E, 100))
    if "die" in $CMDS:
        die()
            
// Demo when statement ("active" qualifier.)
when distance($TARGET) &lt; 120000:
    push("nav_comp_prepare_approach")
    push("gui_change_mode_approach")
    reset when distance($TARGET) &gt; 140000

// Demo commmand ("responsive" qualifier.)
command thruster_fire(e_val):
    e = extract($E, e_val)
    inject($fuel_rod, e)


</t>
<t tx="cslos77.20141214080158.6">@language shiva

// Data types.
x = 5                // integer
y = 5.2              // float
z_str = "hello"      // str
q_list = [4,2,5]    // list

// Shiva lib.
cycle(&lt;list&gt;, rate)
blend(img_A, img_B, mix)
f = random(1.0)
v = unit(&lt;vec&gt;)


// Shakti lib.
e = extract($E, 45)
inject(&lt;obj&gt;, $E(200))

f = convert(e, direction($TARGET))
accelerate(f)
rotate(f)

push("some_command", [45, arg])
arg_list = pull("some_command")
arg_list = touch("some_command")

// Vishnu lib.
dst = distance($Target)
dir = direction($TARGET)
vel = velocity($TARGET)
rot = rotation($TARGET)
mom = momentum($TARGET)
tor = torque($TARGET)
pos = position($TARGET)
</t>
<t tx="cslos77.20150302085211.3"></t>
<t tx="cslos77.20150302085211.9"></t>
</tnodes>
</leo_file>
